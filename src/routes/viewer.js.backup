const express = require('express')
const router = express.Router()

router.get('/', (req, res) => {
  const definitions = req.app.get('definitions') || []

  // Get the definition parameter if provided
  const definitionParam = req.query.definition || 'TopoOpt.gh'
  const selectedDefinition = definitions.find(d => d.name === definitionParam) || definitions[0]

  const viewerHtml = `
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>SoftlyPlease - 3D Geometry Viewer</title>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
        <style>
            * { margin: 0; padding: 0; box-sizing: border-box; }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                background: #1a1a1a;
                color: #ffffff;
                height: 100vh;
                overflow: hidden;
            }
            .viewer-container {
                display: flex;
                height: 100vh;
            }
            .sidebar {
                width: 300px;
                background: #2a2a2a;
                padding: 20px;
                border-right: 1px solid #444;
                overflow-y: auto;
            }
            .viewer-main {
                flex: 1;
                position: relative;
            }
            .back-link {
                position: fixed;
                top: 20px;
                left: 20px;
                background: rgba(255, 255, 255, 0.1);
                color: #ffffff;
                padding: 10px 20px;
                border-radius: 25px;
                text-decoration: none;
                font-weight: 500;
                z-index: 1000;
                border: 1px solid rgba(255, 255, 255, 0.2);
            }
            .header {
                margin-bottom: 30px;
            }
            .header h1 {
                font-size: 2rem;
                margin-bottom: 10px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
            }
            .header p {
                color: #ccc;
                font-size: 0.9rem;
                line-height: 1.5;
            }
            .definition-selector {
                margin-bottom: 30px;
            }
            .definition-selector select {
                width: 100%;
                padding: 12px;
                background: #3a3a3a;
                border: 1px solid #555;
                border-radius: 8px;
                color: #ffffff;
                font-size: 1rem;
                margin-bottom: 15px;
            }
            .definition-selector select:focus {
                outline: none;
                border-color: #667eea;
            }
            .parameters-section {
                margin-bottom: 30px;
            }
            .parameters-section h3 {
                color: #667eea;
                margin-bottom: 15px;
                font-size: 1.1rem;
            }
            .param-group {
                margin-bottom: 20px;
                padding: 15px;
                background: #333;
                border-radius: 8px;
            }
            .param-group label {
                display: block;
                margin-bottom: 8px;
                color: #ccc;
                font-size: 0.9rem;
            }
            .param-group input[type="range"] {
                width: 100%;
                margin: 10px 0;
            }
            .param-group input[type="number"] {
                width: 100%;
                padding: 8px;
                background: #444;
                border: 1px solid #555;
                border-radius: 4px;
                color: #ffffff;
                font-size: 0.9rem;
            }
            .param-group input:focus {
                outline: none;
                border-color: #667eea;
            }
            .param-value {
                display: inline-block;
                margin-left: 10px;
                min-width: 40px;
                text-align: right;
                color: #667eea;
                font-weight: bold;
            }

            /* TopoOpt Configurator Styles */
            .param-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                gap: 25px;
                margin-bottom: 30px;
            }

            .param-group {
                background: #f8f9fa;
                padding: 20px;
                border-radius: 15px;
                border-left: 4px solid #667eea;
            }

            .param-group h3 {
                color: #667eea;
                margin-bottom: 15px;
                font-size: 1.1rem;
                font-weight: 600;
            }

            .param-item {
                margin-bottom: 15px;
            }

            .param-label {
                display: block;
                margin-bottom: 8px;
                font-weight: 500;
                color: #555;
            }

            .param-input {
                width: 100%;
                padding: 12px;
                border: 2px solid #e1e5e9;
                border-radius: 8px;
                font-size: 1rem;
                transition: all 0.3s ease;
            }

            .param-input:focus {
                outline: none;
                border-color: #667eea;
                box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            }

            .slider-container {
                position: relative;
            }

            .slider {
                width: 100%;
                height: 6px;
                background: #e1e5e9;
                border-radius: 3px;
                outline: none;
                -webkit-appearance: none;
            }

            .slider::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 20px;
                height: 20px;
                border-radius: 50%;
                background: #667eea;
                cursor: pointer;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            }

            .value-display {
                position: absolute;
                right: 0;
                top: -25px;
                background: #667eea;
                color: white;
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 0.8rem;
                font-weight: 600;
            }
            .control-buttons {
                margin-top: 30px;
            }
            .btn {
                width: 100%;
                padding: 12px 20px;
                margin-bottom: 10px;
                border: none;
                border-radius: 8px;
                font-size: 1rem;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.3s ease;
            }
            .btn-primary {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
            }
            .btn-primary:hover {
                transform: translateY(-2px);
                box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
            }
            .btn-secondary {
                background: #444;
                color: #ccc;
                border: 1px solid #555;
            }
            .btn-secondary:hover {
                background: #555;
                color: #ffffff;
            }
            .status-panel {
                margin-top: 20px;
                padding: 15px;
                border-radius: 8px;
                font-size: 0.9rem;
            }
            .status-loading {
                background: #2a4a2a;
                color: #90EE90;
                border: 1px solid #4a8a4a;
            }
            .status-success {
                background: #2a4a2a;
                color: #90EE90;
                border: 1px solid #4a8a4a;
            }
            .status-error {
                background: #4a2a2a;
                color: #ff9090;
                border: 1px solid #8a4a4a;
            }
            .export-buttons {
                margin-top: 20px;
            }
            .export-buttons .btn {
                margin-bottom: 8px;
                font-size: 0.9rem;
                padding: 8px 15px;
            }
            #viewer {
                width: 100%;
                height: 100%;
                background: #1a1a1a;
            }
            .viewer-overlay {
                position: absolute;
                top: 20px;
                right: 20px;
                background: rgba(0, 0, 0, 0.8);
                padding: 15px;
                border-radius: 8px;
                color: #ffffff;
                font-size: 0.9rem;
                z-index: 100;
                min-width: 200px;
            }
            .viewer-overlay h4 {
                margin-bottom: 10px;
                color: #667eea;
            }
            .viewer-overlay p {
                margin-bottom: 5px;
                color: #ccc;
            }
            @media (max-width: 768px) {
                .viewer-container {
                    flex-direction: column;
                }
                .sidebar {
                    width: 100%;
                    height: 40vh;
                }
                .viewer-main {
                    height: 60vh;
                }

                /* TopoOpt responsive styles */
                .param-grid {
                    grid-template-columns: 1fr;
                    gap: 15px;
                }

                .param-group {
                    padding: 15px;
                }

                .param-group h3 {
                    font-size: 1rem;
                }

                .param-label {
                    font-size: 0.9rem;
                }

                .param-input {
                    padding: 10px;
                    font-size: 0.9rem;
                }

                .value-display {
                    font-size: 0.7rem;
                    padding: 3px 6px;
                }
            }
        </style>
    </head>
    <body>
        <a href="/" class="back-link">‚Üê Back to Home</a>
        <div class="viewer-container">
            <div class="sidebar">
                <div class="header">
                    <h1>üëÅÔ∏è 3D Geometry Viewer</h1>
                    <p>Visualize Grasshopper computation results in real-time</p>
                </div>

                <div class="definition-selector">
                    <select id="definitionSelect">
                        \${definitions.map(def => \`
                            <option value="\${def.name}" \${def.name === definitionParam ? 'selected' : ''}>
                                \${def.name.replace('.gh', '')}
                            </option>
                        \`).join('')}
                    </select>
                </div>

                <div class="parameters-section">
                    <h3>‚öôÔ∏è Parameters</h3>
                    <div id="parametersContainer">
                        <div id="topoopt-configurator" style="display: none;">
                            <div class="param-grid">
                                <div class="param-group">
                                    <h3>üéõÔ∏è MultiPipe Parameters</h3>
                                    <div class="param-item">
                                        <label class="param-label">Smooth</label>
                                        <div class="slider-container">
                                            <input type="range" class="slider" id="smooth" min="0" max="10" value="3" step="1">
                                            <span class="value-display" id="smooth-value">3</span>
                                        </div>
                                    </div>
                                    <div class="param-item">
                                        <label class="param-label">Cube</label>
                                        <div class="slider-container">
                                            <input type="range" class="slider" id="cube" min="0" max="10" value="2" step="1">
                                            <span class="value-display" id="cube-value">2</span>
                                        </div>
                                    </div>
                                    <div class="param-item">
                                        <label class="param-label">Segment</label>
                                        <div class="slider-container">
                                            <input type="range" class="slider" id="segment" min="1" max="20" value="8" step="1">
                                            <span class="value-display" id="segment-value">8</span>
                                        </div>
                                    </div>
                                    <div class="param-item">
                                        <label class="param-label">Pipe Width</label>
                                        <div class="slider-container">
                                            <input type="range" class="slider" id="pipewidth" min="1" max="50" value="10" step="1">
                                            <span class="value-display" id="pipewidth-value">10</span>
                                        </div>
                                    </div>
                                </div>

                                <div class="param-group">
                                    <h3>üîß Mesh Processing</h3>
                                    <div class="param-item">
                                        <label class="param-label">Round</label>
                                        <div class="slider-container">
                                            <input type="range" class="slider" id="round" min="0" max="10" value="2" step="1">
                                            <span class="value-display" id="round-value">2</span>
                                        </div>
                                    </div>
                                    <div class="param-item">
                                        <label class="param-label">Tolerance</label>
                                        <div class="slider-container">
                                            <input type="range" class="slider" id="tolerance" min="0" max="100" value="5" step="1">
                                            <span class="value-display" id="tolerance-value">5</span>
                                        </div>
                                    </div>
                                    <div class="param-item">
                                        <label class="param-label">MINR (Smaller Than)</label>
                                        <div class="slider-container">
                                            <input type="range" class="slider" id="minr" min="1" max="100" value="10" step="1">
                                            <span class="value-display" id="minr-value">10</span>
                                        </div>
                                    </div>
                                    <div class="param-item">
                                        <label class="param-label">MAXR (Larger Than)</label>
                                        <div class="slider-container">
                                            <input type="range" class="slider" id="maxr" min="1" max="200" value="50" step="1">
                                            <span class="value-display" id="maxr-value">50</span>
                                        </div>
                                    </div>
                                </div>

                                <div class="param-group">
                                    <h3>üéØ Output Options</h3>
                                    <div class="param-item">
                                        <label class="param-label">Output Format</label>
                                        <select class="param-input" id="format">
                                            <option value="mesh">Mesh (SUBD)</option>
                                            <option value="brep">BREP</option>
                                            <option value="stl">STL</option>
                                            <option value="obj">OBJ</option>
                                        </select>
                                    </div>
                                    <div class="param-item">
                                        <label class="param-label">Quality Level</label>
                                        <div class="slider-container">
                                            <input type="range" class="slider" id="quality" min="1" max="10" value="5" step="1">
                                            <span class="value-display" id="quality-value">5</span>
                                        </div>
                                    </div>
                                    <div class="param-item">
                                        <label class="param-label">Detail Level</label>
                                        <div class="slider-container">
                                            <input type="range" class="slider" id="detail" min="1" max="20" value="10" step="1">
                                            <span class="value-display" id="detail-value">10</span>
                                        </div>
                                    </div>
                                </div>

                                <div class="param-group">
                                    <h3>üîß Advanced Options</h3>
                                    <div class="param-item">
                                        <label class="param-label">
                                            <input type="checkbox" id="preview" style="margin-right: 8px;" checked>
                                            Show Preview
                                        </label>
                                    </div>
                                    <div class="param-item">
                                        <label class="param-label">
                                            <input type="checkbox" id="optimize" style="margin-right: 8px;" checked>
                                            Optimize Mesh
                                        </label>
                                    </div>
                                    <div class="param-item">
                                        <label class="param-label">
                                            <input type="checkbox" id="export" style="margin-right: 8px;">
                                            Export on Complete
                                        </label>
                                    </div>
                                    <div class="param-item">
                                        <label class="param-label">Processing Mode</label>
                                        <select class="param-input" id="mode">
                                            <option value="fast">Fast</option>
                                            <option value="balanced" selected>Balanced</option>
                                            <option value="quality">High Quality</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div id="generic-parameters">
                            <p style="color: #ccc; font-size: 0.9rem;">Select a definition to load parameters</p>
                        </div>
                    </div>
                </div>

                <div class="control-buttons">
                    <button id="computeBtn" class="btn btn-primary">
                        üöÄ Generate Geometry
                    </button>
                    <button id="resetViewBtn" class="btn btn-secondary">
                        üîÑ Reset View
                    </button>
                </div>

                <div class="export-buttons">
                    <h3>üì§ Export</h3>
                    <button id="exportOBJ" class="btn btn-secondary">
                        üìÑ Export OBJ
                    </button>
                    <button id="exportSTL" class="btn btn-secondary">
                        üèóÔ∏è Export STL
                    </button>
                    <button id="exportJSON" class="btn btn-secondary">
                        üìä Export JSON
                    </button>
                </div>

                <div id="statusPanel" class="status-panel" style="display: none;">
                    <div id="statusContent">Ready to compute</div>
                </div>
            </div>

            <div class="viewer-main">
                <div id="viewer"></div>
                <div class="viewer-overlay">
                    <h4>üéÆ Controls</h4>
                    <p><strong>Rotate:</strong> Left click + drag</p>
                    <p><strong>Zoom:</strong> Mouse wheel</p>
                    <p><strong>Pan:</strong> Right click + drag</p>
                    <p><strong>Reset:</strong> Double click</p>
                </div>
            </div>
        </div>

        <script>
            // Three.js 3D Viewer
            class GeometryViewer {
                constructor(containerId) {
                    this.container = document.getElementById(containerId);
                    this.scene = null;
                    this.camera = null;
                    this.renderer = null;
                    this.controls = null;
                    this.currentGeometry = null;

                    this.init();
                }

                init() {
                    // Scene setup
                    this.scene = new THREE.Scene();
                    this.scene.background = new THREE.Color(0x1a1a1a);

                    // Camera setup
                    this.camera = new THREE.PerspectiveCamera(
                        75,
                        this.container.clientWidth / this.container.clientHeight,
                        0.1,
                        1000
                    );
                    this.camera.position.set(10, 10, 10);

                    // Renderer setup
                    this.renderer = new THREE.WebGLRenderer({ antialias: true });
                    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                    this.renderer.setClearColor(0x1a1a1a);
                    this.container.appendChild(this.renderer.domElement);

                    // Controls setup
                    this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                    this.controls.enableDamping = true;
                    this.controls.dampingFactor = 0.05;
                    this.controls.enableZoom = true;
                    this.controls.enablePan = true;

                    // Lighting
                    this.setupLighting();

                    // Grid helper
                    this.addGridHelper();

                    // Animation loop
                    this.animate();

                    // Handle resize
                    window.addEventListener('resize', () => this.onWindowResize());
                }

                setupLighting() {
                    // Ambient light
                    const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                    this.scene.add(ambientLight);

                    // Directional light
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
                    directionalLight.position.set(10, 10, 5);
                    this.scene.add(directionalLight);

                    // Point light
                    const pointLight = new THREE.PointLight(0xffffff, 0.8);
                    pointLight.position.set(-10, -10, 10);
                    this.scene.add(pointLight);
                }

                addGridHelper() {
                    const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
                    gridHelper.position.y = -0.01;
                    this.scene.add(gridHelper);

                    // Add axes helper
                    const axesHelper = new THREE.AxesHelper(5);
                    this.scene.add(axesHelper);
                }

                clearScene() {
                    // Remove current geometry
                    if (this.currentGeometry) {
                        this.scene.remove(this.currentGeometry);
                        this.currentGeometry = null;
                    }

                    // Clear any existing meshes
                    this.scene.children = this.scene.children.filter(child => {
                        return child.type === 'AmbientLight' ||
                               child.type === 'DirectionalLight' ||
                               child.type === 'PointLight' ||
                               child.type === 'GridHelper' ||
                               child.type === 'AxesHelper';
                    });
                }

                loadGeometry(result) {
                    this.clearScene();

                    console.log('üîç Loading geometry from result:', result);

                    let geometryData = null;

                    // Handle different response formats
                    if (result.data && result.data.values) {
                        // Real Rhino Compute response
                        geometryData = result.data.values;
                        console.log('üìä Using real Rhino Compute data:', geometryData.length, 'values');
                    } else if (result.data && result.data.geometry) {
                        // Mock data format
                        console.log('üé≠ Using mock data format');
                        // For mock data, create some basic geometry based on the parameters
                        this.createMockGeometryFromParameters(result.data.inputs);
                        return;
                    } else {
                        console.warn('‚ùå No geometry data found in result');
                        return;
                    }

                    // Group for all geometry
                    const geometryGroup = new THREE.Group();

                    // Process each value in the response
                    geometryData.forEach((value, index) => {
                        try {
                            console.log('üîß Processing value ' + index + ':', value);

                            // Handle different geometry types from Rhino Compute
                            if (value.type === 'Mesh' && value.data) {
                                const mesh = this.createMeshFromRhinoData(value.data);
                                if (mesh) {
                                    mesh.position.x = index * 3; // Space out multiple geometries
                                    geometryGroup.add(mesh);
                                    console.log('‚úÖ Added mesh ' + index);
                                }
                            } else if (value.type === 'Brep' && value.data) {
                                const brepMesh = this.createBrepFromRhinoData(value.data);
                                if (brepMesh) {
                                    brepMesh.position.x = index * 3;
                                    geometryGroup.add(brepMesh);
                                    console.log('‚úÖ Added brep ' + index);
                                }
                            } else if (value.type === 'Curve' && value.data) {
                                const curveMesh = this.createCurveFromRhinoData(value.data);
                                if (curveMesh) {
                                    curveMesh.position.x = index * 3;
                                    geometryGroup.add(curveMesh);
                                    console.log('‚úÖ Added curve ' + index);
                                }
                            } else if (value.type === 'Point' && value.data) {
                                const pointMesh = this.createPointFromRhinoData(value.data);
                                if (pointMesh) {
                                    pointMesh.position.x = index * 3;
                                    geometryGroup.add(pointMesh);
                                    console.log('‚úÖ Added point ' + index);
                                }
                            } else {
                                console.log('‚ö†Ô∏è  Unknown or empty value type:', value.type, value);
                            }
                        } catch (error) {
                            console.error('‚ùå Error processing value ' + index + ':', error);
                        }
                    });

                    // Center and scale the geometry
                    if (geometryGroup.children.length > 0) {
                        console.log('üé® Adding ' + geometryGroup.children.length + ' geometry objects to scene');

                        const box = new THREE.Box3().setFromObject(geometryGroup);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());

                        // Center the geometry
                        geometryGroup.position.sub(center);

                        // Scale to fit viewport
                        const maxDim = Math.max(size.x, size.y, size.z);
                        if (maxDim > 10) {
                            const scale = 10 / maxDim;
                            geometryGroup.scale.setScalar(scale);
                        }

                        this.scene.add(geometryGroup);
                        this.currentGeometry = geometryGroup;

                        // Adjust camera to fit geometry
                        this.fitCameraToObject(geometryGroup);

                        console.log('‚úÖ Geometry loaded and displayed successfully');
                    } else {
                        console.warn('‚ö†Ô∏è  No valid geometry objects created');
                        // Create a fallback geometry to show something
                        this.createFallbackGeometry();
                    }
                }

                createMockGeometryFromParameters(inputs) {
                    console.log('üé≠ Creating mock geometry from parameters:', inputs);

                    // Create a simple geometry based on input parameters
                    const geometryGroup = new THREE.Group();

                    // Use input values to influence the geometry
                    const smooth = inputs.smooth?.[0] || 3;
                    const cube = inputs.cube?.[0] || 2;
                    const segment = inputs.segment?.[0] || 8;
                    const pipewidth = inputs.pipewidth?.[0] || 10;

                    // Create a box with dimensions based on parameters
                    const boxGeometry = new THREE.BoxGeometry(
                        pipewidth / 10,
                        segment / 2,
                        cube * 2
                    );
                    const boxMaterial = new THREE.MeshLambertMaterial({
                        color: 0x667eea,
                        wireframe: false
                    });
                    const box = new THREE.Mesh(boxGeometry, boxMaterial);
                    geometryGroup.add(box);

                    // Add some variation based on smooth parameter
                    if (smooth > 5) {
                        const sphereGeometry = new THREE.SphereGeometry(1, 16, 16);
                        const sphereMaterial = new THREE.MeshLambertMaterial({
                            color: 0x764ba2,
                            wireframe: false
                        });
                        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                        sphere.position.x = 3;
                        geometryGroup.add(sphere);
                    }

                    // Center and scale
                    const box = new THREE.Box3().setFromObject(geometryGroup);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());

                    geometryGroup.position.sub(center);

                    const maxDim = Math.max(size.x, size.y, size.z);
                    if (maxDim > 10) {
                        const scale = 10 / maxDim;
                        geometryGroup.scale.setScalar(scale);
                    }

                    this.scene.add(geometryGroup);
                    this.currentGeometry = geometryGroup;
                    this.fitCameraToObject(geometryGroup);

                    console.log('‚úÖ Mock geometry created and displayed');
                }

                createFallbackGeometry() {
                    console.log('üì¶ Creating fallback geometry');

                    const geometry = new THREE.BoxGeometry(2, 2, 2);
                    const material = new THREE.MeshLambertMaterial({
                        color: 0xff6b6b,
                        wireframe: true
                    });
                    const cube = new THREE.Mesh(geometry, material);
                    this.scene.add(cube);
                    this.currentGeometry = cube;

                    console.log('‚úÖ Fallback geometry created');
                }

                // Methods for creating geometry from Rhino Compute data
                createMeshFromRhinoData(meshData) {
                    try {
                        console.log('üî∫ Creating mesh from Rhino data:', meshData);

                        // For now, create a simple representation
                        // In a full implementation, this would parse the actual mesh vertices/faces
                        const geometry = new THREE.BoxGeometry(1, 1, 1);
                        const material = new THREE.MeshLambertMaterial({
                            color: 0x667eea,
                            wireframe: false
                        });
                        return new THREE.Mesh(geometry, material);
                    } catch (error) {
                        console.error('Error creating mesh from Rhino data:', error);
                        return null;
                    }
                }

                createBrepFromRhinoData(brepData) {
                    try {
                        console.log('üî∫ Creating brep from Rhino data:', brepData);

                        // Create a sphere to represent brep geometry
                        const geometry = new THREE.SphereGeometry(0.8, 32, 32);
                        const material = new THREE.MeshLambertMaterial({
                            color: 0x764ba2,
                            wireframe: false
                        });
                        return new THREE.Mesh(geometry, material);
                    } catch (error) {
                        console.error('Error creating brep from Rhino data:', error);
                        return null;
                    }
                }

                createCurveFromRhinoData(curveData) {
                    try {
                        console.log('üî∫ Creating curve from Rhino data:', curveData);

                        // Create a torus knot to represent curve geometry
                        const geometry = new THREE.TorusKnotGeometry(0.5, 0.2, 64, 8);
                        const material = new THREE.MeshLambertMaterial({
                            color: 0x4CAF50,
                            wireframe: true
                        });
                        return new THREE.Mesh(geometry, material);
                    } catch (error) {
                        console.error('Error creating curve from Rhino data:', error);
                        return null;
                    }
                }

                createPointFromRhinoData(pointData) {
                    try {
                        console.log('üî∫ Creating point from Rhino data:', pointData);

                        // Create an octahedron to represent point geometry
                        const geometry = new THREE.OctahedronGeometry(0.3);
                        const material = new THREE.MeshLambertMaterial({
                            color: 0xFF9800,
                            wireframe: false
                        });
                        return new THREE.Mesh(geometry, material);
                    } catch (error) {
                        console.error('Error creating point from Rhino data:', error);
                        return null;
                    }
                }

                fitCameraToObject(object) {
                    const box = new THREE.Box3().setFromObject(object);
                    const size = box.getSize(new THREE.Vector3());
                    const center = box.getCenter(new THREE.Vector3());

                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = this.camera.fov * (Math.PI / 180);
                    let cameraZ = Math.abs(maxDim / Math.sin(fov / 2));

                    cameraZ *= 2; // Add some padding

                    this.camera.position.set(center.x, center.y, cameraZ);
                    this.controls.target.copy(center);
                    this.controls.update();
                }

                animate() {
                    requestAnimationFrame(() => this.animate());
                    this.controls.update();
                    this.renderer.render(this.scene, this.camera);
                }

                onWindowResize() {
                    this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                }

                resetView() {
                    if (this.currentGeometry) {
                        this.fitCameraToObject(this.currentGeometry);
                    } else {
                        this.camera.position.set(10, 10, 10);
                        this.controls.target.set(0, 0, 0);
                        this.controls.update();
                    }
                }
            }

            // Initialize the viewer
            let viewer = null;
            let currentDefinition = '\${definitionParam}';
            let currentParameters = {};

            document.addEventListener('DOMContentLoaded', function() {
                // Initialize viewer
                viewer = new GeometryViewer('viewer');

                // Load parameters for selected definition
                loadDefinitionParameters(currentDefinition);

                // Event listeners
                document.getElementById('definitionSelect').addEventListener('change', function(e) {
                    currentDefinition = e.target.value;
                    loadDefinitionParameters(currentDefinition);
                });

                // Add TopoOpt parameter update listeners
                function updateTopoOptValueDisplays() {
                    // MultiPipe Parameters
                    if (document.getElementById('smooth')) {
                        document.getElementById('smooth-value').textContent = document.getElementById('smooth').value;
                        document.getElementById('cube-value').textContent = document.getElementById('cube').value;
                        document.getElementById('segment-value').textContent = document.getElementById('segment').value;
                        document.getElementById('pipewidth-value').textContent = document.getElementById('pipewidth').value;

                        // Mesh Processing
                        document.getElementById('round-value').textContent = document.getElementById('round').value;
                        document.getElementById('tolerance-value').textContent = document.getElementById('tolerance').value;
                        document.getElementById('minr-value').textContent = document.getElementById('minr').value;
                        document.getElementById('maxr-value').textContent = document.getElementById('maxr').value;

                        // Output Options
                        document.getElementById('quality-value').textContent = document.getElementById('quality').value;
                        document.getElementById('detail-value').textContent = document.getElementById('detail').value;
                    }
                }

                // Initialize TopoOpt parameter displays
                updateTopoOptValueDisplays();

                // Add event listeners for TopoOpt sliders
                const topoOptIds = ['smooth', 'cube', 'segment', 'pipewidth', 'round', 'tolerance', 'minr', 'maxr', 'quality', 'detail'];
                topoOptIds.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('input', updateTopoOptValueDisplays);
                    }
                });

                document.getElementById('computeBtn').addEventListener('click', computeGeometry);
                document.getElementById('resetViewBtn').addEventListener('click', () => viewer.resetView());

                // Export buttons
                document.getElementById('exportOBJ').addEventListener('click', () => exportGeometry('obj'));
                document.getElementById('exportSTL').addEventListener('click', () => exportGeometry('stl'));
                document.getElementById('exportJSON').addEventListener('click', () => exportGeometry('json'));
            });

            async function loadDefinitionParameters(definitionName) {
                try {
                    // Check if this is TopoOpt.gh
                    if (definitionName === 'TopoOpt.gh') {
                        // Show TopoOpt configurator
                        document.getElementById('topoopt-configurator').style.display = 'block';
                        document.getElementById('generic-parameters').style.display = 'none';
                        updateTopoOptValueDisplays();
                    } else {
                        // Hide TopoOpt configurator and show generic parameters
                        document.getElementById('topoopt-configurator').style.display = 'none';
                        document.getElementById('generic-parameters').style.display = 'block';

                        // Try to load parameters from API
                        const response = await fetch(\`/definition/\${definitionName}\`);
                        if (response.ok) {
                            const data = await response.json();
                            displayParameters(data.inputs || []);
                        } else {
                            document.getElementById('generic-parameters').innerHTML = '<p style="color: #ccc; font-size: 0.9rem;">Definition loaded but no parameters available</p>';
                        }
                    }
                } catch (error) {
                    console.error('Error loading parameters:', error);
                    document.getElementById('generic-parameters').innerHTML = '<p style="color: #ccc; font-size: 0.9rem;">Error loading parameters</p>';
                }
            }

            function displayParameters(parameters) {
                const container = document.getElementById('parametersContainer');

                if (!parameters || parameters.length === 0) {
                    container.innerHTML = '<p style="color: #ccc; font-size: 0.9rem;">No parameters available for this definition</p>';
                    return;
                }

                container.innerHTML = '';

                parameters.forEach(param => {
                    const paramGroup = document.createElement('div');
                    paramGroup.className = 'param-group';

                    const label = document.createElement('label');
                    label.textContent = \`\${param.name} (\${param.paramType})\`;

                    let input;
                    if (param.paramType === 'Number') {
                        input = document.createElement('input');
                        input.type = 'range';
                        input.min = '0';
                        input.max = '10';
                        input.step = '0.1';
                        input.value = '5';
                    } else if (param.paramType === 'Integer') {
                        input = document.createElement('input');
                        input.type = 'range';
                        input.min = '1';
                        input.max = '20';
                        input.step = '1';
                        input.value = '8';
                    } else {
                        input = document.createElement('input');
                        input.type = 'number';
                        input.value = '1';
                    }

                    const valueDisplay = document.createElement('span');
                    valueDisplay.className = 'param-value';
                    valueDisplay.textContent = input.value;

                    input.addEventListener('input', function() {
                        valueDisplay.textContent = this.value;
                        currentParameters[param.name] = [parseFloat(this.value)];
                    });

                    // Set initial value
                    currentParameters[param.name] = [parseFloat(input.value)];

                    paramGroup.appendChild(label);
                    paramGroup.appendChild(input);
                    paramGroup.appendChild(valueDisplay);
                    container.appendChild(paramGroup);
                });
            }

            async function computeGeometry() {
                const statusPanel = document.getElementById('statusPanel');
                const statusContent = document.getElementById('statusContent');

                statusPanel.style.display = 'block';
                statusPanel.className = 'status-panel status-loading';
                statusContent.textContent = 'üîÑ Computing geometry...';

                try {
                    let inputs = {};

                    // Check if this is TopoOpt.gh and collect specific parameters
                    if (currentDefinition === 'TopoOpt.gh') {
                        inputs = {
                            // MultiPipe Parameters
                            smooth: [parseInt(document.getElementById('smooth')?.value || '3')],
                            cube: [parseInt(document.getElementById('cube')?.value || '2')],
                            segment: [parseInt(document.getElementById('segment')?.value || '8')],
                            pipewidth: [parseInt(document.getElementById('pipewidth')?.value || '10')],

                            // Mesh Processing Parameters
                            round: [parseInt(document.getElementById('round')?.value || '2')],
                            tolerance: [parseInt(document.getElementById('tolerance')?.value || '5')],
                            minr: [parseInt(document.getElementById('minr')?.value || '10')],
                            maxr: [parseInt(document.getElementById('maxr')?.value || '50')],

                            // Output Options
                            format: [document.getElementById('format')?.value || 'mesh'],
                            quality: [parseInt(document.getElementById('quality')?.value || '5')],
                            detail: [parseInt(document.getElementById('detail')?.value || '10')],

                            // Advanced Options
                            preview: [document.getElementById('preview')?.checked || true],
                            optimize: [document.getElementById('optimize')?.checked || true],
                            export: [document.getElementById('export')?.checked || false],
                            mode: [document.getElementById('mode')?.value || 'balanced']
                        };
                    } else {
                        // Use generic parameters for other definitions
                        inputs = currentParameters;
                    }

                    const response = await fetch('/solve', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            definition: currentDefinition,
                            inputs: inputs
                        })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        statusPanel.className = 'status-panel status-success';
                        statusContent.textContent = '‚úÖ Geometry computed successfully!';

                        // Display the geometry in the viewer
                        viewer.loadGeometry(result);

                        // Hide status after 3 seconds
                        setTimeout(() => {
                            statusPanel.style.display = 'none';
                        }, 3000);
                    } else {
                        const error = await response.json();
                        statusPanel.className = 'status-panel status-error';
                        statusContent.textContent = \`‚ùå Error: \${error.message || 'Unknown error'}\`;
                    }
                } catch (error) {
                    statusPanel.className = 'status-panel status-error';
                    statusContent.textContent = \`‚ùå Network Error: \${error.message}\`;
                }
            }

            function exportGeometry(format) {
                if (!viewer.currentGeometry) {
                    alert('No geometry to export. Please compute geometry first.');
                    return;
                }

                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                const filename = \`\${currentDefinition.replace('.gh', '')}_\${timestamp}\`;

                switch (format) {
                    case 'obj':
                        exportAsOBJ(filename);
                        break;
                    case 'stl':
                        exportAsSTL(filename);
                        break;
                    case 'json':
                        exportAsJSON(filename);
                        break;
                }
            }

            function exportAsOBJ(filename) {
                // In a real implementation, this would use a proper OBJ exporter
                console.log(\`Exporting \${filename}.obj\`);
                alert(\`OBJ export not yet implemented. Would export: \${filename}.obj\`);
            }

            function exportAsSTL(filename) {
                // In a real implementation, this would use a proper STL exporter
                console.log(\`Exporting \${filename}.stl\`);
                alert(\`STL export not yet implemented. Would export: \${filename}.stl\`);
            }

            function exportAsJSON(filename) {
                const data = {
                    definition: currentDefinition,
                    parameters: currentParameters,
                    geometry: viewer.currentGeometry ? viewer.currentGeometry.toJSON() : null,
                    timestamp: new Date().toISOString()
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = \`\${filename}.json\`;
                a.click();
                URL.revokeObjectURL(url);
            }

            // Handle window resize
            window.addEventListener('resize', function() {
                if (viewer) {
                    viewer.onWindowResize();
                }
            });
        </script>
    </body>
</html>`

module.exports = router
