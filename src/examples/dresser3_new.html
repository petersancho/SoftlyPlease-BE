<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Compute 3D Dresser</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: sans-serif;
            background: white;
            color: black;
        }

        #container {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        #app {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        #sidebar {
            position: absolute;
            left: 0;
            top: 0;
            width: 300px;
            height: 100%;
            background: #f8f8f8;
            border-right: 1px solid #ddd;
            padding: 20px;
            overflow-y: auto;
            z-index: 100;
        }

        #sidebar h1 {
            font-size: 1.5rem;
            margin: 0 0 20px 0;
            color: #333;
        }

        .slider-group {
            margin-bottom: 30px;
        }

        .slider-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #333;
        }

        .slider {
            width: 100%;
            margin-bottom: 5px;
        }

        .slider-value {
            display: block;
            text-align: center;
            font-weight: bold;
            color: #666;
            font-size: 1.1rem;
        }

        #loader {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #ddd;
            z-index: 1000;
        }

        #download-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 10px 20px;
            background: #333;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 100;
        }

        #download-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        #download-button:hover:not(:disabled) {
            background: #555;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="sidebar">
            <h1>3D Dresser</h1>

            <div class="slider-group">
                <label for="width">Width (50-300)</label>
                <input type="range" id="width" class="slider" min="50" max="300" value="100" step="10">
                <span id="width-value" class="slider-value">100</span>
            </div>

            <div class="slider-group">
                <label for="height">Height (100-400)</label>
                <input type="range" id="height" class="slider" min="100" max="400" value="200" step="10">
                <span id="height-value" class="slider-value">200</span>
            </div>

            <div class="slider-group">
                <label for="depth">Depth (30-150)</label>
                <input type="range" id="depth" class="slider" min="30" max="150" value="50" step="5">
                <span id="depth-value" class="slider-value">50</span>
            </div>
        </div>

        <div id="app"></div>

        <div id="loader">Computing...</div>

        <button id="download-button" disabled>Download .3dm</button>
    </div>

    <script type="module">
        import * as THREE from 'three'
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'
        import { Rhino3dmLoader } from 'three/examples/jsm/loaders/3DMLoader'
        import rhino3dm from 'rhino3dm'

        const definition = 'dresser3.gh'

        // setup input change events
        const width_slider = document.getElementById('width')
        const width_value = document.getElementById('width-value')
        width_slider.addEventListener('input', () => {
            width_value.textContent = width_slider.value
            onSliderChange()
        })
        width_slider.addEventListener('change', onSliderChange)

        const height_slider = document.getElementById('height')
        const height_value = document.getElementById('height-value')
        height_slider.addEventListener('input', () => {
            height_value.textContent = height_slider.value
            onSliderChange()
        })
        height_slider.addEventListener('change', onSliderChange)

        const depth_slider = document.getElementById('depth')
        const depth_value = document.getElementById('depth-value')
        depth_slider.addEventListener('input', () => {
            depth_value.textContent = depth_slider.value
            onSliderChange()
        })
        depth_slider.addEventListener('change', onSliderChange)

        // load the rhino3dm library
        let rhino, doc

        try {
            rhino = await rhino3dm()
            console.log('Loaded rhino3dm.')
        } catch (error) {
            console.error('Failed to load rhino3dm:', error)
        }

        const loader = new Rhino3dmLoader()
        loader.setLibraryPath('https://unpkg.com/rhino3dm@8.0.0-beta/')

        init()
        compute()

        /**
         * Call appserver
         */
        async function compute() {
            showSpinner(true)

            // collect data from inputs
            let data = {}
            data.definition = definition
            data.inputs = {
                'Width': width_slider.valueAsNumber,
                'Height': height_slider.valueAsNumber,
                'Depth': depth_slider.valueAsNumber
            }

            console.log(data.inputs)

            const request = {
                'method': 'POST',
                'body': JSON.stringify(data),
                'headers': {'Content-Type': 'application/json'}
            }

            try {
                const response = await fetch('/solve', request)

                if (!response.ok)
                    throw new Error(response.statusText)

                const responseJson = await response.json()

                collectResults(responseJson)

            } catch (error) {
                console.error(error)
                showSpinner(false)
            }
        }

        /**
         * Parse response
         */
        function collectResults(responseJson) {
            const values = responseJson.values

            // clear doc
            if (doc !== undefined)
                doc.delete()

            doc = new rhino.File3dm()

            // for each output (RH_OUT:*)...
            for (let i = 0; i < values.length; i++) {
                // ...iterate through data tree structure...
                for (const path in values[i].InnerTree) {
                    const branch = values[i].InnerTree[path]
                    // ...and for each branch...
                    for (let j = 0; j < branch.length; j++) {
                        // ...load rhino geometry into doc
                        const rhinoObject = decodeItem(branch[j])
                        if (rhinoObject !== null) {
                            doc.objects().add(rhinoObject, null)
                        }
                    }
                }
            }

            if (doc.objects().count < 1) {
                console.error('No rhino objects to load!')
                showSpinner(false)
                return
            }

            // load rhino doc into three.js scene
            const buffer = new Uint8Array(doc.toByteArray()).buffer
            loader.parse(buffer, function (object) {
                // debug
                object.traverse(child => {
                    if (child.material)
                        child.material = new THREE.MeshBasicMaterial({ vertexColors: true })
                }, false)

                // clear objects from scene. do this here to avoid blink
                scene.traverse(child => {
                    if (!child.isLight && child.name !== 'context') {
                        scene.remove(child)
                    }
                })

                // add object graph from rhino model to three.js scene
                scene.add(object)

                // hide spinner and enable download button
                showSpinner(false)
                document.getElementById('download-button').disabled = false

                // zoom to extents
                zoomCameraToSelection(camera, controls, scene.children)

            }, (error) => {
                console.error(error)
            })
        }

        /**
         * Shows or hides the loading spinner
         */
        function showSpinner(enable) {
            document.getElementById('loader').style.display = enable ? 'block' : 'none'
        }

        /**
         * Attempt to decode data tree item to rhino geometry
         */
        function decodeItem(item) {
            const data = JSON.parse(item.data)
            if (item.type === 'System.String') {
                // hack for draco meshes
                try {
                    const decompressed = rhino.DracoCompression.decompressBase64String(data)
                    if (decompressed) {
                        console.log('Draco decompression successful')
                        return decompressed
                    }
                } catch (e) {
                    console.warn('Draco decompression failed:', e)
                }
                // If Draco fails, try treating as regular geometry string
                try {
                    return rhino.CommonObject.decode(JSON.parse(data))
                } catch (e) {
                    console.warn('Geometry decode failed:', e)
                }
            } else if (typeof data === 'object') {
                try {
                    return rhino.CommonObject.decode(data)
                } catch (e) {
                    console.warn('Object decode failed:', e)
                }
            }
            return null
        }

        /**
         * Called when a slider value changes in the UI. Collect all of the
         * slider values and call compute to solve for a new scene
         */
        function onSliderChange() {
            compute()
        }

        // BOILERPLATE //

        let scene, camera, renderer, controls

        function init() {
            // Rhino models are z-up, so set this as the default
            THREE.Object3D.DefaultUp = new THREE.Vector3(0, 0, 1);

            scene = new THREE.Scene()
            scene.background = new THREE.Color(1, 1, 1)
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000)

            renderer = new THREE.WebGLRenderer({ antialias: true })
            renderer.setPixelRatio(window.devicePixelRatio)
            renderer.setSize(window.innerWidth, window.innerHeight)
            document.getElementById('app').appendChild(renderer.domElement)

            controls = new OrbitControls(camera, renderer.domElement)

            camera.position.z = 50

            window.addEventListener('resize', onWindowResize, false)

            animate()
        }

        function animate() {
            requestAnimationFrame(animate)
            controls.update()
            renderer.render(scene, camera)
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight
            camera.updateProjectionMatrix()
            renderer.setSize(window.innerWidth, window.innerHeight)
            animate()
        }

        function zoomCameraToSelection(camera, controls, selection, fitOffset = 1.1) {
            const box = new THREE.Box3();

            for (const object of selection) {
                if (object.isLight) continue;
                box.expandByObject(object);
            }

            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            const maxSize = Math.max(size.x, size.y, size.z);
            const fitHeightDistance = maxSize / (2 * Math.atan(Math.PI * camera.fov / 360));
            const fitWidthDistance = fitHeightDistance / camera.aspect;
            const distance = fitOffset * Math.max(fitHeightDistance, fitWidthDistance);

            const direction = controls.target.clone()
                .sub(camera.position)
                .normalize()
                .multiplyScalar(distance);

            controls.maxDistance = distance * 10;
            controls.target.copy(center);

            camera.near = distance / 100;
            camera.far = distance * 100;
            camera.updateProjectionMatrix();

            camera.position.copy(controls.target).sub(direction);

            controls.update();
        }

        // Download functionality
        document.getElementById('download-button').addEventListener('click', function() {
            if (!doc) return;

            const bytes = doc.toByteArray();
            const blob = new Blob([bytes], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'dresser.3dm';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });
    </script>
</body>
</html>
