<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>SoftlyPlease — Monochrome Points</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
  <meta name="color-scheme" content="light">
  <meta name="description" content="SoftlyPlease — raw, black & white, Times New Roman. Frontpage enhanced with a deterministic monochrome pointillism portrait.">
  <style>
    /* Raw, black-and-white, Times New Roman aesthetic */
    html,body{height:100%;margin:0;background:#fff;color:#000;font:16px "Times New Roman", Times, serif;line-height:1.4;
        overflow-x:hidden;touch-action:manipulation;-webkit-overflow-scrolling:touch}
    /* Canvas occupies the full viewport; links sit above it */
    #art{position:fixed;inset:0;z-index:0;display:block;width:100vw;height:100vh;background:#fff}
    /* Content layer with your raw hyperlinks */
    #content{position:relative;z-index:1;max-width:720px;margin:40px auto;padding:0 16px}
    #content h1{font-size:28px;margin:0 0 12px 0;font-weight:700}
    #content p{margin:8px 0}
    #links a{color:#000;text-decoration:underline}
    #links a:hover{background:#000;color:#fff}
    /* Mobile-responsive tuning UI (hidden by default; show with ?ui=1) */
    #ui{position:fixed;left:8px;bottom:8px;right:8px;padding:12px;border:1px solid #000;background:#fff;
        display:none;border-radius:12px;max-width:100%;box-sizing:border-box;
        z-index:10;backdrop-filter:blur(4px);box-shadow:0 4px 12px rgba(0,0,0,0.15)}
    #ui label{display:flex;flex-direction:column;gap:4px;text-align:left;font-size:14px;font-weight:500}
    #ui .control-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    #ui input[type="range"]{width:100%;max-width:150px;height:8px;border-radius:4px;
        -webkit-appearance:none;appearance:none;background:#e0e0e0;outline:none}
    #ui input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;
        width:20px;height:20px;border-radius:50%;background:#000;cursor:pointer;touch-action:none}
    #ui input[type="range"]::-moz-range-thumb{width:20px;height:20px;border-radius:50%;
        background:#000;border:none;cursor:pointer}
    #ui input[type="text"]{width:100%;max-width:180px;padding:8px 10px;border:1px solid #ccc;
        border-radius:6px;font-size:14px}
    #ui button{padding:10px 16px;border-radius:8px;border:1px solid #000;background:#000;
        color:#fff;font-size:14px;font-weight:500;cursor:pointer;touch-action:none;
        min-height:44px;width:100%;max-width:120px}
    #ui .seed-section{display:flex;flex-direction:column;gap:6px;width:100%}

    /* Mobile-specific adjustments */
    @media (max-width: 768px) {
        #ui{left:4px;bottom:4px;right:4px;padding:8px;border-radius:8px}
        #ui .control-row{flex-direction:column;gap:12px}
        #ui label{font-size:12px}
        #ui input[type="range"]{max-width:100%}
        #ui input[type="text"]{max-width:100%;padding:6px 8px}
        #ui button{min-height:40px;padding:8px 12px;font-size:13px;max-width:100%}
    }

    /* Hide UI on very small screens unless specifically requested */
    @media (max-width: 480px) {
        #ui{display:none !important}
        #ui.show{display:flex !important}
    }
    #banner{position:fixed;right:12px;bottom:12px;background:#eee;border:1px solid #000;padding:8px 10px;border-radius:6px}
    noscript{position:relative;z-index:1;display:block;margin:12px 16px;padding:8px 10px;border:1px solid #000;background:#fff}
  </style>
</head>
<body>
  <!-- Progressive enhancement: raw content stays functional without JS/canvas -->
  <canvas id="art" aria-label="Monochrome pointillism portrait"></canvas>

  <div id="content" role="main">
    <h1>SoftlyPlease</h1>
    <div id="links" aria-label="Site links">
      <p><a href="/examples/">McNeel Examples</a> · <a href="/my-examples/">My Examples</a> · <a href="/status">Compute Status</a></p>
      <p>This is the raw frontpage. Black and white. Times New Roman. The art behind this text is algorithmic and deterministic.</p>
    </div>
  </div>

  <!-- Mobile-responsive controls; visit with ?ui=1 to reveal during tuning/export -->
  <div id="ui" aria-hidden="true" title="Hidden by default. Add ?ui=1 to the URL to show this.">
    <div class="control-row">
      <label>Step Size
        <input id="step" type="range" min="3" max="16" value="6">
      </label>
      <label>Dot Size
        <input id="dot" type="range" min="1" max="6" value="3.2" step="0.1">
      </label>
    </div>
    <div class="seed-section">
      <label>Seed (for deterministic art)
        <input id="seed" type="text" placeholder="SOFTLYPLEASE-001">
      </label>
      <button id="download" type="button">Download 4K PNG</button>
    </div>
  </div>

  <noscript>This page enhances with a black-and-white pointillism canvas when JavaScript is enabled.</noscript>

  <script>
  // ——— Config (monochrome only) ———
  const BG = '#ffffff';           // white background
  const INK = '#000000';          // black dots
  const MARGIN_CSS = 40;          // content margin in CSS px
  let stepCSS = 6;                // grid step (lower = more dots)
  let dotMaxCSS = 3.2;            // max dot radius in CSS px
  const dotMinCSS = 0.25;         // min dot radius
  const jitterScale = 0.35;       // organic jitter as fraction of step
  const params = new URLSearchParams(location.search);
  // Default seed keeps output deterministic; override with ?seed=
  let seedStr = (params.get('seed') || 'SOFTLYPLEASE-001').trim();
  const showUI = params.get('ui') === '1';
  // Portrait is generated programmatically - no external image needed

  // ——— Seeded RNG (deterministic) ———
  function cyrb128(str){let h1=1779033703,h2=3144134277,h3=1013904242,h4=2773480762;for(let i=0;i<str.length;i++){let ch=str.charCodeAt(i);h1=h2^Math.imul(h1^ch,597399067);h2=h3^Math.imul(h2^ch,2869860233);h3=h4^Math.imul(h3^ch,951274213);h4=h1^Math.imul(h4^ch,2716044179);}h1=Math.imul(h3^(h1>>>18),597399067);h2=Math.imul(h4^(h2>>>22),2869860233);h3=Math.imul(h1^(h3>>>17),951274213);h4=Math.imul(h2^(h4>>>19),2716044179);return[(h1^h2^h3^h4)>>>0,h1>>>0,h2>>>0,h3>>>0];}
  function sfc32(a,b,c,d){return function(){a|=0;b|=0;c|=0;d|=0;let t=(a+b|0)+d|0;d=d+1|0;a=b^(b>>>9);b=c+(c<<3)|0;c=(c<<21)|(c>>>11);c=c+t|0;return(t>>>0)/4294967296;}}
  function makeRng(seed){const h=cyrb128(seed||String(Math.random()));return sfc32(h[0],h[1],h[2],h[3]);}
  let rng = makeRng(seedStr);

  // ——— Elements ———
  const canvas = document.getElementById('art');
  const ctx = canvas.getContext('2d', { alpha:false, desynchronized:true });
  const off = document.createElement('canvas');
  const octx = off.getContext('2d', { willReadFrequently:true });
  const state = { dpr:1, dx:0, dy:0, dw:0, dh:0 };

  const ui = document.getElementById('ui');
  const stepEl = document.getElementById('step');
  const dotEl  = document.getElementById('dot');
  const seedEl = document.getElementById('seed');
  const dlBtn  = document.getElementById('download');

  // Mobile-friendly UI handling
  if (showUI) {
    ui.style.display = 'flex';
    ui.setAttribute('aria-hidden','false');
    // Add .show class for mobile override
    ui.classList.add('show');
  }

  // Touch-friendly slider handling
  function handleTouchStart(e) {
    e.preventDefault(); // Prevent scrolling while adjusting
  }

  function handleTouchEnd(e) {
    e.preventDefault();
  }

  // Add touch event listeners for mobile
  if ('ontouchstart' in window) {
    stepEl.addEventListener('touchstart', handleTouchStart, { passive: false });
    stepEl.addEventListener('touchend', handleTouchEnd, { passive: false });
    dotEl.addEventListener('touchstart', handleTouchStart, { passive: false });
    dotEl.addEventListener('touchend', handleTouchEnd, { passive: false });
  }

  // ——— Generate programmatic portrait ———
  const img = { naturalWidth: 512, naturalHeight: 512, complete: true };
  img.onload = () => { fit(); render(); };

  // Create programmatic portrait using canvas drawing
  function generatePortrait() {
    const portraitCanvas = document.createElement('canvas');
    portraitCanvas.width = 512;
    portraitCanvas.height = 512;
    const pctx = portraitCanvas.getContext('2d');

    // Fill with skin tone background
    pctx.fillStyle = '#F5DEB3'; // Wheat color for skin
    pctx.fillRect(0, 0, 512, 512);

    // Draw simple face outline
    pctx.strokeStyle = '#8B4513'; // SaddleBrown for outline
    pctx.lineWidth = 3;
    pctx.beginPath();
    pctx.ellipse(256, 200, 120, 150, 0, 0, Math.PI * 2);
    pctx.stroke();

    // Draw eyes
    pctx.fillStyle = '#000000';
    pctx.beginPath();
    pctx.ellipse(220, 180, 8, 8, 0, 0, Math.PI * 2);
    pctx.fill();
    pctx.beginPath();
    pctx.ellipse(292, 180, 8, 8, 0, 0, Math.PI * 2);
    pctx.fill();

    // Draw nose
    pctx.strokeStyle = '#8B4513';
    pctx.lineWidth = 2;
    pctx.beginPath();
    pctx.moveTo(256, 190);
    pctx.lineTo(256, 220);
    pctx.lineTo(246, 235);
    pctx.moveTo(256, 220);
    pctx.lineTo(266, 235);
    pctx.stroke();

    // Draw mouth
    pctx.beginPath();
    pctx.arc(256, 250, 20, 0, Math.PI);
    pctx.stroke();

    // Draw hair
    pctx.fillStyle = '#4B0082'; // Indigo for hair
    pctx.beginPath();
    pctx.arc(256, 130, 80, Math.PI, 0);
    pctx.fill();

    // Draw neck
    pctx.strokeStyle = '#F5DEB3';
    pctx.lineWidth = 20;
    pctx.beginPath();
    pctx.moveTo(236, 320);
    pctx.lineTo(236, 380);
    pctx.moveTo(276, 320);
    pctx.lineTo(276, 380);
    pctx.stroke();

    // Add some shading/highlights for better pointillism
    pctx.fillStyle = 'rgba(0,0,0,0.1)'; // subtle shadows
    pctx.beginPath();
    pctx.ellipse(240, 190, 100, 120, 0, Math.PI*1.2, Math.PI*0.8);
    pctx.fill();

    pctx.fillStyle = 'rgba(255,255,255,0.3)'; // subtle highlights
    pctx.beginPath();
    pctx.ellipse(280, 160, 40, 40, 0, 0, Math.PI * 2);
    pctx.fill();

    return portraitCanvas;
  }

  // Generate the portrait
  const portraitCanvas = generatePortrait();

  // Set up img properties to mimic loaded image
  img.naturalWidth = portraitCanvas.width;
  img.naturalHeight = portraitCanvas.height;

  // Override getImageData to use our generated portrait
  const originalGetImageData = octx.getImageData;
  octx.getImageData = function(sx, sy, sw, sh) {
    // Draw our portrait to offscreen canvas
    octx.clearRect(0, 0, off.width, off.height);
    octx.drawImage(portraitCanvas, 0, 0, off.width, off.height);
    return originalGetImageData.call(octx, sx, sy, sw, sh);
  };

  // Trigger onload
  img.onload();

  // ——— UI bindings ———
  stepEl && stepEl.addEventListener('input', e => { stepCSS = +e.target.value; render(); });
  dotEl  && dotEl.addEventListener('input',  e => { dotMaxCSS = +e.target.value; render(); });
  seedEl && seedEl.addEventListener('change', e => { seedStr = e.target.value.trim() || 'SOFTLYPLEASE-001'; rng = makeRng(seedStr); render(); });

  // Mobile-friendly download button
  dlBtn && dlBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    download4k();
  }, { passive: false });

  dlBtn && dlBtn.addEventListener('click', (e) => {
    e.preventDefault();
    download4k();
  });

  // Add mobile-specific feedback
  if ('ontouchstart' in window) {
    // Add haptic feedback simulation for mobile
    const originalRender = render;
    render = function() {
      originalRender();
      // Slight visual feedback for mobile interactions
      if (showUI) {
        ui.style.transform = 'scale(0.98)';
        setTimeout(() => { ui.style.transform = 'scale(1)'; }, 100);
      }
    };
  }
  window.addEventListener('resize', () => { fit(); render(); });

  // ——— Layout & offscreen prep ———
  function fit(){
    const dpr = window.devicePixelRatio || 1;
    state.dpr = dpr;
    canvas.width  = Math.floor(window.innerWidth  * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = BG; ctx.fillRect(0,0,canvas.width,canvas.height);

    const margin = MARGIN_CSS * dpr;
    const iw = img.naturalWidth || 1, ih = img.naturalHeight || 1;
    const scale = Math.min((canvas.width - 2*margin)/iw, (canvas.height - 2*margin)/ih);
    const dw = Math.max(1, Math.floor(iw * scale));
    const dh = Math.max(1, Math.floor(ih * scale));
    const dx = Math.floor((canvas.width  - dw) / 2);
    const dy = Math.floor((canvas.height - dh) / 2);
    Object.assign(state, {dx,dy,dw,dh});

    off.width = dw; off.height = dh;
    if (portraitCanvas && portraitCanvas.width && portraitCanvas.height) {
      octx.setTransform(1,0,0,1,0,0);
      octx.clearRect(0,0,off.width,off.height);
      octx.drawImage(portraitCanvas, 0, 0, off.width, off.height);
    }
  }

  // ——— Render (display) ———
  function render(){
    const { dpr, dx, dy, dw, dh } = state;
    if (!dw || !dh) return;
    ctx.fillStyle = BG; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.save(); ctx.translate(dx,dy);

    const data = octx.getImageData(0,0,off.width,off.height).data;
    const stepPx   = Math.max(2, Math.round(stepCSS * dpr));
    const dotMaxPx = dotMaxCSS * dpr;
    const dotMinPx = dotMinCSS * dpr;
    const jitter   = jitterScale * stepPx;

    // Re-seed per render for determinism
    const r = rng = makeRng(seedStr);

    for (let y=0; y<dh; y+=stepPx){
      const row = y * dw * 4;
      for (let x=0; x<dw; x+=stepPx){
        const i = row + x*4;
        const R=data[i], G=data[i+1], B=data[i+2], A=data[i+3];
        if (A===0) continue;
        // Luminance -> dot size (brighter = smaller)
        const L=(0.2126*R + 0.7152*G + 0.0722*B)/255;
        const radius = dotMaxPx - (dotMaxPx - dotMinPx)*L;
        if (radius < 0.15*dpr) continue;
        const jx=(r()*2-1)*jitter, jy=(r()*2-1)*jitter;
        ctx.beginPath();
        ctx.arc(x + jx, y + jy, radius, 0, Math.PI*2);
        ctx.fillStyle = INK;
        ctx.fill();
      }
    }
    ctx.restore();
  }

  // ——— High-res export (4K longest side) ———
  async function download4k(){
    if (!portraitCanvas) return;
    const btn = document.getElementById('download');
    if (btn) btn.disabled = true;
    try{
      const targetLong = 4096; // 4K long side
      const iw = portraitCanvas.width, ih = portraitCanvas.height;
      const out = document.createElement('canvas');
      const long = Math.max(iw, ih);
      const scale = targetLong / long;
      out.width  = Math.round(iw * scale);
      out.height = Math.round(ih * scale);

      const margin = Math.round(MARGIN_CSS * (out.width / (state.dw || out.width)));
      const dw = out.width  - 2*margin;
      const dh = out.height - 2*margin;

      const src = document.createElement('canvas');
      src.width = dw; src.height = dh;
      const sctx = src.getContext('2d', { willReadFrequently:true });
      sctx.drawImage(portraitCanvas,0,0,dw,dh);
      const sdata = sctx.getImageData(0,0,dw,dh).data;

      const octx2 = out.getContext('2d');
      octx2.fillStyle = BG; octx2.fillRect(0,0,out.width,out.height);
      octx2.save(); octx2.translate(margin,margin);

      // Scale step/dots relative to export size
      const stepPx   = Math.max(2, Math.round(stepCSS * (dw / (state.dw || dw))));
      const dotMaxPx = dotMaxCSS * (dw / (state.dw || dw));
      const dotMinPx = dotMinCSS * (dw / (state.dw || dw));
      const jitter   = jitterScale * stepPx;

      const r = makeRng(seedStr);

      for (let y=0; y<dh; y+=stepPx){
        const row = y * dw * 4;
        for (let x=0; x<dw; x+=stepPx){
          const i = row + x*4;
          const R=sdata[i], G=sdata[i+1], B=sdata[i+2], A=sdata[i+3];
          if (A===0) continue;
          const L=(0.2126*R + 0.7152*G + 0.0722*B)/255;
          const radius = dotMaxPx - (dotMaxPx - dotMinPx)*L;
          if (radius < 0.15) continue;
          const jx=(r()*2-1)*jitter, jy=(r()*2-1)*jitter;
          octx2.beginPath();
          octx2.arc(x + jx, y + jy, radius, 0, Math.PI*2);
          octx2.fillStyle = INK;
          octx2.fill();
        }
      }
      octx2.restore();

      // Small, optional seed mark for provenance
      if (seedStr){
        octx2.fillStyle = '#000'; octx2.globalAlpha = 0.65;
        octx2.font = '600 18px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
        octx2.textAlign = 'right';
        octx2.fillText(`#${seedStr}`, out.width - 14, out.height - 14);
        octx2.globalAlpha = 1;
      }

      const url = out.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url;
      a.download = `softlyplease_monochrome_points_${seedStr || 'unseeded'}.png`;
      a.click();
    } finally {
      if (btn) btn.disabled = false;
    }
  }
  </script>
</body>
</html>